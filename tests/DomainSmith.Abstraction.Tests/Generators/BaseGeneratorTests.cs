using System.Text;
using DomainSmith.Abstraction.Generators;
using FluentAssertions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace DomainSmith.Abstraction.Tests.Generators;

public sealed class BaseGeneratorTests
{
    // Pomocniczy atrybut do oznaczania klas dla testów
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Interface)]
    private sealed class DummyGenAttribute : Attribute
    {
    }

    // Informacja przekazywana do generatora
    private sealed class ClassToAugment(string name, string? ns, List<string> usings)
    {
        public string Name { get; } = name;
        public string? Namespace { get; } = ns;
        public List<string> Usings { get; } = usings;
    }

    // Testowy generator oparty o BaseGenerator
    private sealed class DummyGenerator : BaseGenerator<MemberDeclarationSyntax, ClassToAugment>
    {
        protected override string AttributeFullName => typeof(DummyGenAttribute).FullName!;

        protected override string GenerateSource(ClassToAugment info)
        {
            var builder = new StringBuilder();
            builder.AppendLine("// <auto-generated/>");
            builder.AppendLine(string.Join("\n", info.Usings));
            if (!string.IsNullOrWhiteSpace(info.Namespace))
            {
                builder.AppendLine($"namespace {info.Namespace};");
            }

            builder.AppendLine();
            builder.AppendLine($"partial class {info.Name}");
            builder.AppendLine("{");
            builder.AppendLine("    public static string Marker => \"Generated\";");
            builder.AppendLine("}");
            return builder.ToString();
        }

        protected override ClassToAugment? CreateInfo(MemberDeclarationSyntax declaration,
            GeneratorSyntaxContext context)
        {
            var syntax = declaration as TypeDeclarationSyntax;
            if (syntax is null) return null;

            var name = syntax.Identifier.Text;
            var ns = syntax.FirstAncestorOrSelf<NamespaceDeclarationSyntax>()?.Name.ToString()
                     ?? syntax.FirstAncestorOrSelf<FileScopedNamespaceDeclarationSyntax>()?.Name.ToString();

            var usings = syntax
                .FirstAncestorOrSelf<CompilationUnitSyntax>()?
                .DescendantNodesAndSelf()
                .OfType<UsingDirectiveSyntax>()
                .Select(x => $"using {x.Name};")
                .Distinct()
                .ToList() ?? [];

            return new ClassToAugment(name, ns, usings);
        }
    }

    private static Compilation CreateCompilation(string source)
    {
        var syntaxTree = CSharpSyntaxTree.ParseText(source);
        var refs = new[]
        {
            MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
            MetadataReference.CreateFromFile(typeof(Enumerable).Assembly.Location),
            MetadataReference.CreateFromFile(typeof(DummyGenAttribute).Assembly.Location),
            MetadataReference.CreateFromFile(typeof(Compilation).Assembly.Location),
            MetadataReference.CreateFromFile(typeof(CSharpCompilation).Assembly.Location),
        };
        return CSharpCompilation.Create(
            assemblyName: "TestsAssembly",
            [syntaxTree],
            refs,
            new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));
    }

    [Fact]
    public void Initialize_WithAttributedClass_ShouldGenerateSourceFile()
    {
        // Arrange
        var inputSource =
            """
            using System;
            using DomainSmith.Abstraction.Tests.Generators;

            namespace TestNamespace;

            [BaseGeneratorTests.DummyGen]
            public partial class Foo
            {
            }
            """;

        var compilation = CreateCompilation(inputSource);
        GeneratorDriver driver = CSharpGeneratorDriver.Create(new DummyGenerator());

        // Act
        driver.RunGeneratorsAndUpdateCompilation(compilation, out var outputCompilation, out var diagnostics);

        // Assert
        diagnostics.Should().BeEmpty();

        var trees = outputCompilation.SyntaxTrees.ToList();
        trees.Should().HaveCount(1);

        var generated = trees.Last().ToString();
        generated.Should().Contain("namespace TestNamespace;");
        generated.Should().Contain("partial class Foo");
    }

    [Fact]
    public void Initialize_WithoutAttribute_ShouldNotGenerateSource()
    {
        // Arrange
        const string inputSource = """
                                   using System;

                                   namespace TestNamespace;

                                   public partial class Bar
                                   {
                                   }
                                   """;

        var compilation = CreateCompilation(inputSource);
        GeneratorDriver driver = CSharpGeneratorDriver.Create(new DummyGenerator());

        // Act
        driver.RunGeneratorsAndUpdateCompilation(compilation, out var outputCompilation, out var diagnostics);

        // Assert
        diagnostics.Should().BeEmpty();
        outputCompilation.SyntaxTrees.Should().HaveCount(1);
        outputCompilation.SyntaxTrees.Single().ToString().Should().Contain("partial class Bar");
    }

    [Fact]
    public void GetFileName_ShouldUseTypeNamePropertyAsDefault()
    {
        // Arrange
        const string inputSource = """
                                   using System;
                                   using DomainSmith.Abstraction.Tests.Generators;

                                   [BaseGeneratorTests.DummyGen]
                                   public partial class Baz
                                   {
                                   }
                                   """;

        var compilation = CreateCompilation(inputSource);
        GeneratorDriver driver = CSharpGeneratorDriver.Create(new DummyGenerator());

        // Act
        driver.RunGeneratorsAndUpdateCompilation(compilation, out var outputCompilation, out _);

        // Assert
        var generated = outputCompilation.SyntaxTrees.Last().ToString();
        generated.Should().Contain("partial class Baz");
    }
}