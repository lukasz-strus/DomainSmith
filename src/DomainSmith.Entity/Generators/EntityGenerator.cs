using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using DomainSmith.Abstraction.Generators;

namespace DomainSmith.Entity.Generators;

[Generator]
public sealed class EntityGenerator : BaseGenerator<ClassDeclarationSyntax, EntityGenerator.ClassToAugment>
{
    protected override string AttributeFullName => typeof(EntityAttribute).FullName!;

    protected override string GenerateSource(ClassToAugment info)
    {
        var ns = string.IsNullOrWhiteSpace(info.Namespace) ? string.Empty : $"namespace {info.Namespace};";
        return $$"""
            // <auto-generated/>
            using DomainSmith.Abstraction.Core.Primitives;
            using DomainSmith.Entity;
            
            {{ns}}
            
            partial class {{info.Name}}
            {
                private {{info.Name}}({{info.TypeArg}} id) : base(id)
                {
                }
            }
            """;
    }

    protected override ClassToAugment? CreateInfo(ClassDeclarationSyntax classSyntax, GeneratorSyntaxContext context)
    {
        var name = classSyntax.Identifier.Text;
        var typeArg = (classSyntax.BaseList?.Types.FirstOrDefault()?.Type as GenericNameSyntax)?.TypeArgumentList.Arguments.FirstOrDefault()?.ToString() ?? "int";
        var ns = classSyntax.FirstAncestorOrSelf<NamespaceDeclarationSyntax>()?.Name.ToString() ??
                 classSyntax.FirstAncestorOrSelf<FileScopedNamespaceDeclarationSyntax>()?.Name.ToString();
        return new ClassToAugment(name, typeArg, ns);
    }

    public sealed class ClassToAugment
    {
        public string Name { get; }
        public string TypeArg { get; }
        public string? Namespace { get; }
        public ClassToAugment(string name, string typeArg, string? ns)
        {
            Name = name;
            TypeArg = typeArg;
            Namespace = ns;
        }
    }
}