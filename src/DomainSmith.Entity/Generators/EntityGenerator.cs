using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using DomainSmith.Abstraction.Generators;

namespace DomainSmith.Entity.Generators;

[Generator]
public sealed class EntityGenerator : BaseGenerator<ClassDeclarationSyntax, EntityGenerator.ClassToAugment>
{
    protected override string AttributeFullName => typeof(EntityAttribute).FullName!;

    protected override string GenerateSource(ClassToAugment info)
    {
        var ns = string.IsNullOrWhiteSpace(info.Namespace) ? string.Empty : $"namespace {info.Namespace};";
        var idValue = GetIdValueExpression(info.TypeArg);
        var extensionName = info.Name + "Extensions";
        var extensionReference = ns == string.Empty
            ? $"{extensionName}"
            : $"{info.Namespace}.{extensionName}";

        return $$"""
                 // <auto-generated/>
                 using System;
                 using DomainSmith.Abstraction.Core.Primitives;
                 using DomainSmith.Entity;

                 {{ns}}

                 partial class {{info.Name}} : Entity<{{info.TypeArg}}>
                 {
                     private {{info.Name}}({{info.TypeArg}} id) : base(id)
                     {
                     }

                     public static {{info.Name}}? Create()
                     {
                         OnCreating();
                         if(!{{extensionReference}}.CanCreate) return null;
                     
                         var result = new {{info.Name}}({{idValue}});
                         
                         OnCreated(result);
                         if(!{{extensionReference}}.CanCreate) return null;
                         
                         return result;
                     }
                     
                     public void Update()
                     {
                         OnUpdating();
                         if(!{{extensionReference}}.CanUpdate) return;
                         
                         OnUpdated();
                         if(!{{extensionReference}}.CanUpdate) return;
                     
                         return;
                     }
                     
                     static partial void OnCreating();
                     static partial void OnCreated({{info.Name}} result);

                     partial void OnUpdating();
                     partial void OnUpdated();
                     
                     private void AllowUpdate()
                     {
                         {{extensionReference}}.CanUpdate = true;
                     }
                     
                     private void AllowCreate()
                     {
                         {{extensionReference}}.CanCreate = true;
                     }
                     
                     private void DisallowUpdate()
                     {
                         {{extensionReference}}.CanUpdate = false;
                     }
                     
                     private void DisallowCreate()
                     {
                         {{extensionReference}}.CanCreate = false;
                     }
                 }

                 file static class {{extensionName}}
                 {
                     public static bool CanCreate = true;
                     public static bool CanUpdate = true;
                 }
                 """;
    }

    private static string GetIdValueExpression(string typeArg)
    {
        return typeArg switch
        {
            "int" => "new Random().Next()",
            "Guid" => "Guid.NewGuid()",
            "string" => "Guid.NewGuid().ToString()",
            _ => "default"
        };
    }

    protected override ClassToAugment CreateInfo(ClassDeclarationSyntax classSyntax, GeneratorSyntaxContext context)
    {
        var name = classSyntax.Identifier.Text;
        var ns = classSyntax.FirstAncestorOrSelf<NamespaceDeclarationSyntax>()?.Name.ToString() ??
                 classSyntax.FirstAncestorOrSelf<FileScopedNamespaceDeclarationSyntax>()?.Name.ToString();

        //var typeArg = (classSyntax.BaseList?.Types.FirstOrDefault()?.Type as GenericNameSyntax)?.TypeArgumentList
        //    .Arguments.FirstOrDefault()?.ToString() ?? "int";

        var typeArg = "int";
        foreach (var attr in classSyntax.AttributeLists
                     .SelectMany(attrList => attrList.Attributes, (attrList, attr) => new { attrList, attr })
                     .Select(@t => new
                     {
                         @t, symbol = context.SemanticModel.GetSymbolInfo(@t.attr).Symbol as IMethodSymbol
                     })
                     .Where(@t => @t.symbol?.ContainingType.ToDisplayString() == AttributeFullName)
                     .Select(@t => @t.@t.attr))
        {
            if (!(attr.ArgumentList?.Arguments.Count > 0)) continue;
            var expr = attr.ArgumentList.Arguments[0].Expression;
            if (expr is TypeOfExpressionSyntax typeOfExpr)
            {
                typeArg = typeOfExpr.Type.ToString();
            }
        }

        return new ClassToAugment(name, typeArg, ns);
    }

    public sealed class ClassToAugment(string name, string typeArg, string? ns)
    {
        public string Name { get; } = name;
        public string TypeArg { get; } = typeArg;
        public string? Namespace { get; } = ns;
    }
}