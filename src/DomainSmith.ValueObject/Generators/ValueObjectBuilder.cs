using DomainSmith.Abstraction.Generators;
using System.Text;

namespace DomainSmith.ValueObject.Generators;

internal sealed class ValueObjectBuilder : BaseBuilder
{
    private readonly StringBuilder _extensionName = new();
    private readonly StringBuilder _extensionReference = new();
    private List<(string Type, string Name)> _properties = [];
    internal void SetExtensionName(string className)
    {
        _extensionName.Clear();
        _extensionName.Append(className);
        _extensionName.Append("Extensions");
    }

    internal void SetExtensionReference(string? @namespace, string className)
    {
        _extensionReference.Clear();

        if (!string.IsNullOrEmpty(@namespace))
        {
            _extensionReference.Append(@namespace);
            _extensionReference.Append(".");
        }

        _extensionReference.Append(className);
        _extensionReference.Append("Extensions");
    }

    internal void SetProperties(List<(string Type, string Name)> properties)
    {
        _properties = [.. properties];
    }

    protected override string BuildSource()
    {
        var ctorParams = new List<string>();
        var ctorAssignments = new List<string>();
        var createParams = new List<string>();
        var createArgs = new List<string>();
        var onCreatingRefParams = new List<string>();
        var onCreatingParams = new List<string>();

        foreach (var (type, name) in _properties)
        {
            var paramName = name.ToLower();
            ctorParams.Add($"{type} {paramName}");
            ctorAssignments.Add($"{name} = {paramName};");
            createParams.Add($"{type} {paramName}");
            createArgs.Add($"{paramName}");
            onCreatingRefParams.Add($"ref {paramName}");
            onCreatingParams.Add($"ref {type} {paramName}");
        }

        var ctorParamsStr = string.Join(", ", ctorParams);
        var ctorAssignmentsStr = string.Join("\n\t\t", ctorAssignments);
        var createParamsStr = string.Join(", ", createParams);
        var createArgsStr = string.Join(", ", createArgs);
        var onCreatingRefParamsStr = string.Join(", ", onCreatingRefParams);
        var onCreatingParamsStr = string.Join(", ", onCreatingParams);

        return $$"""
                 // <auto-generated/>
                 {{Usings}}

                 {{Namespace}}

                 partial record {{ClassName}}
                 {
                     private {{ClassName}}({{ctorParamsStr}})
                     {
                         {{ctorAssignmentsStr}}
                     }

                     public static {{ClassName}}? Create({{createParamsStr}})
                     {
                         OnCreating({{onCreatingRefParamsStr}});
                         
                         var result = new {{ClassName}}({{createArgsStr}});

                         OnCreated(result);
                         if (!{{_extensionReference}}.CanCreate) return null;

                         return result;
                     }

                     static partial void OnCreating({{onCreatingParamsStr}});
                     static partial void OnCreated({{ClassName}} instance);

                     private void AllowCreate()
                     {
                         {{_extensionReference}}.CanCreate = true;
                     }

                     private void DisallowCreate()
                     {
                         {{_extensionReference}}.CanCreate = false;
                     }
                 }

                 public static partial class {{_extensionName}}
                 {
                     private static readonly System.Threading.AsyncLocal<bool?> _canCreate = new();

                     public static bool CanCreate
                     {
                         get => _canCreate.Value ?? true;
                         set => _canCreate.Value = value;
                     }

                     public static System.IDisposable UseCreate(bool value) => new Scope(_canCreate, value);

                     private sealed class Scope : System.IDisposable
                     {
                         private readonly System.Threading.AsyncLocal<bool?> _local;
                         private readonly bool? _previous;

                         public Scope(System.Threading.AsyncLocal<bool?> local, bool value)
                         {
                             _local = local;
                             _previous = local.Value;
                             local.Value = value;
                         }

                         public void Dispose() => _local.Value = _previous;
                     }
                 }
                 """;
    }

    protected override bool IsEmpty()
    {
        return Usings.Length == 0 &&
               Namespace.Length == 0 &&
               ClassName.Length == 0;
    }
}
